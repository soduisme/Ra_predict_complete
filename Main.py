# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p863UnxRBtaTOHW3y-GBzf6MtAYwsilq
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.neural_network import MLPRegressor
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import mean_squared_error, r2_score
from scipy.interpolate import griddata
import joblib

st.set_page_config(page_title="–ü—Ä–æ–≥–Ω–æ–∑ —à–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç–∏ Ra", layout="wide")
st.title("–ü—Ä–æ–≥–Ω–æ–∑ —à–µ—Ä–æ—Ö–æ–≤–∞—Ç–æ—Å—Ç–∏ Ra –∏ –æ–±—Ä–∞—Ç–Ω—ã–π –ø–æ–∏—Å–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–æ –∂–µ–ª–∞–µ–º–æ–º—É Ra –ø—Ä–∏ —Ñ—Ä–µ–∑–µ—Ä–æ–≤–∞–Ω–∏–∏ —Å—Ç–∞–ª–∏ 20")
st.markdown("""
**–°–æ–∑–¥–∞—Ç–µ–ª—å**: –ù–≥—É–µ–Ω –ù–≥–æ–∫ –®–æ–Ω - –ú–¢3/–ú–ì–¢–£ –∏–º. –ë–∞—É–º–∞–Ω–∞

**–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç**: –¢–æ—Ä—Ü–µ–≤–∞—è —Ñ—Ä–µ–∑–∞ BAP300R-40-22 (D=40 –º–º, –∑—É–±—å–µ–≤), –ø–ª–∞—Å—Ç–∏–Ω—ã APMT1135PDER-M2 OP1215.
""")
@st.cache_data
def load_and_train_model():
    df = pd.read_excel("du_lieu_frezing.xlsx")
    X = df[['V', 'S', 't']]
    y = df['Ra']
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

    param_grid = {
        'hidden_layer_sizes': [(30, 20)],
        'learning_rate_init': [0.0005],
        'activation': ['tanh']
    }
    grid = GridSearchCV(MLPRegressor(max_iter=5000, early_stopping=True, random_state=42),
                        param_grid, cv=3, scoring='r2', n_jobs=-1, return_train_score=True)
    grid.fit(X_train, y_train)
    model = grid.best_estimator_
    results_df = pd.DataFrame(grid.cv_results_)
    return df, scaler, model, X_test, y_test, X_train, y_train, results_df, param_grid
df, scaler, model, X_test, y_test, X_train, y_train, results_df, param_grid = load_and_train_model()

tab1, tab2, tab3 = st.tabs(["\U0001F4CA –î–∞–Ω–Ω—ã–µ –∏ –≥—Ä–∞—Ñ–∏–∫–∏", "\U0001F50D –û–±—Ä–∞—Ç–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ Ra", "\U0001F4C8 –ü—Ä–æ–≥–Ω–æ–∑ Ra"])

with tab1:
    st.subheader("üìä –ì—Ä–∞—Ñ–∏–∫ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è Ra (–ø—Ä–æ–≥–Ω–æ–∑ –ø—Ä–æ—Ç–∏–≤ —Ñ–∞–∫—Ç)")
    y_pred = model.predict(scaler.transform(X_test))
    train_pred = model.predict(scaler.transform(X_train))
    fig, ax = plt.subplots()
    ax.scatter(y_train, train_pred, color='red', label='–û–±—É—á–∞—é—â–∞—è –≤—ã–±–æ—Ä–∫–∞')
    ax.scatter(y_test, y_pred, color='blue', label='–¢–µ—Å—Ç–æ–≤–∞—è –≤—ã–±–æ—Ä–∫–∞')
    ax.plot([min(df['Ra']), max(df['Ra'])], [min(df['Ra']), max(df['Ra'])], 'k--', label='–ò–¥–µ–∞–ª')
    ax.set_xlabel('–§–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ Ra (Œºm)')
    ax.set_ylabel('–ü—Ä–æ–≥–Ω–æ–∑–∏—Ä—É–µ–º–æ–µ Ra (Œºm)')
    ax.set_title('–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –∏ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π Ra')
    ax.legend()
    ax.grid(True)
    st.pyplot(fig)

    st.markdown("### üìã –¢–∞–±–ª–∏—Ü–∞ –ø—Ä–æ–≥–Ω–æ–∑–æ–≤")
    X_test_orig = scaler.inverse_transform(X_test)
    df_pred = pd.DataFrame(X_test_orig, columns=['V', 'S', 't'])
    df_pred['Ra —Ñ–∞–∫—Ç'] = y_test.values
    df_pred['Ra –ø—Ä–æ–≥–Ω–æ–∑'] = y_pred
    df_pred['–û—à–∏–±–∫–∞'] = abs(df_pred['Ra —Ñ–∞–∫—Ç'] - df_pred['Ra –ø—Ä–æ–≥–Ω–æ–∑'])
    st.dataframe(df_pred.round(4))

    st.markdown("### üìâ –û–±—É—á–∞—é—â–∞—è –∫—Ä–∏–≤–∞—è")
    if hasattr(model, 'loss_curve_'):
        fig2, ax2 = plt.subplots()
        ax2.plot(model.loss_curve_)
        ax2.set_title("–ö—Ä–∏–≤–∞—è –æ–±—É—á–µ–Ω–∏—è")
        ax2.set_xlabel("–≠–ø–æ—Ö–∏")
        ax2.set_ylabel("–û—à–∏–±–∫–∞")
        st.pyplot(fig2)

    st.markdown("### üåê –ì—Ä–∞—Ñ–∏–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ Ra –æ—Ç (S, V)")
    x, yv, z = df['S'], df['V'], df['Ra']
    xi = np.linspace(x.min(), x.max(), 100)
    yi = np.linspace(yv.min(), yv.max(), 100)
    xi, yi = np.meshgrid(xi, yi)
    zi = griddata((x, yv), z, (xi, yi), method='cubic')
    fig3, ax3 = plt.subplots()
    cp = ax3.contourf(xi, yi, zi, cmap='viridis')
    fig3.colorbar(cp)
    ax3.set_xlabel('S (–º–º/–∑—É–±)')
    ax3.set_ylabel('V (–º/–º–∏–Ω)')
    ax3.set_title('Ra –ø–æ (S, V)')
    st.pyplot(fig3)

    st.markdown("### üåê –ì—Ä–∞—Ñ–∏–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ Ra –æ—Ç (S, t)")
    x, yt, z = df['S'], df['t'], df['Ra']
    xi = np.linspace(x.min(), x.max(), 100)
    yi = np.linspace(yt.min(), yt.max(), 100)
    xi, yi = np.meshgrid(xi, yi)
    zi = griddata((x, yt), z, (xi, yi), method='cubic')
    fig4, ax4 = plt.subplots()
    cp = ax4.contourf(xi, yi, zi, cmap='plasma')
    fig4.colorbar(cp)
    ax4.set_xlabel('S (–º–º/–∑—É–±)')
    ax4.set_ylabel('t (–º–º)')
    ax4.set_title('Ra –ø–æ (S, t)')
    st.pyplot(fig4)

    st.markdown("### üß† –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥–µ–ª–∏ MLP")
    st.write(f"**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–∫—Ä—ã—Ç—ã—Ö —Å–ª–æ—ë–≤**: {model.hidden_layer_sizes}")
    st.write(f"**–§—É–Ω–∫—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏**: {model.activation}")
    st.write(f"**–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –æ–±—É—á–µ–Ω–∏—è**: {model.learning_rate_init}")
    st.write(f"**–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π –æ–±—É—á–µ–Ω–∏—è**: {model.n_iter_}")

with tab2:
    st.subheader("\U0001F50D –û–±—Ä–∞—Ç–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ Ra")
    target_ra = st.number_input("–ñ–µ–ª–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ Ra (Œºm):", 0.1, 10.0, 1.2, 0.1)
    num_results = st.slider("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–±–∏–Ω–∞—Ü–∏–π –¥–ª—è –≤—ã–≤–æ–¥–∞:", 1, 10, 4)

    if st.button("\U0001F50E –ù–∞–π—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"):
        V_range = np.linspace(df['V'].min(), df['V'].max(), 30)
        S_range = np.linspace(df['S'].min(), df['S'].max(), 30)
        t_range = np.linspace(df['t'].min(), df['t'].max(), 30)
        results = []
        for v in V_range:
            for s in S_range:
                for t in t_range:
                    input_df = pd.DataFrame([[v, s, t]], columns=['V', 'S', 't'])
                    input_scaled = scaler.transform(input_df)
                    ra = model.predict(input_scaled)[0]
                    err = abs(ra - target_ra)
                    results.append((err, v, s, t, ra))
        results.sort()
        out_df = pd.DataFrame(results[:num_results], columns=['–û—à–∏–±–∫–∞', 'V (–º/–º–∏–Ω)', 'S (–º–º/–∑—É–±)', 't (–º–º)', 'Ra –ø—Ä–æ–≥–Ω–æ–∑'])
        st.dataframe(out_df)

with tab3:
    st.subheader("\U0001F4C8 –ü—Ä–æ–≥–Ω–æ–∑ Ra")
    v = st.number_input("–°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ–∑–∞–Ω–∏—è V (–º/–º–∏–Ω):",60.0, 120.0, 60.0, 5.0)
    s = st.number_input("–ü–æ–¥–∞—á–∞ –Ω–∞ –∑—É–± S (–º–º/–∑—É–±):", 0.05, 0.25, 0.05, 0.01)
    t = st.number_input("–ì–ª—É–±–∏–Ω–∞ —Ä–µ–∑–∞–Ω–∏—è t (–º–º):", 0.3, 1.5, 0.3, 0.1)

    if st.button("\U0001F4C9 –ü—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞—Ç—å Ra"):
        input_df = pd.DataFrame([[v, s, t]], columns=['V', 'S', 't'])
        input_scaled = scaler.transform(input_df)
        ra_pred = model.predict(input_scaled)[0]
        st.success(f"–ü—Ä–æ–≥–Ω–æ–∑–∏—Ä—É–µ–º–æ–µ Ra: {ra_pred:.4f} Œºm –ø—Ä–∏ V={v} –º/–º–∏–Ω, S={s} –º–º/–∑—É–±, t={t} –º–º")
